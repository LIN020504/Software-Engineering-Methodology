# Lab2问题

## 关于版本控制系统
### **概念**：
    版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统，我们可以对任何类型的文件进行版本控制。  
    使用版本控制系统的优点在于：不论我们怎么更改，我们都可以轻松返回之前的版本，而工作量却非常小。

### **本地版本控制系统**：
    大多都是采用某种简单的数据库来记录文件的历次更新差异。
    
### **集中化的版本控制系统（Centralized Version Control Systems）**:
    这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。

    这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。

    事分两面，有好有坏。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。

 ### **分布式版本控制系统（Distributed Version Control System）**:
    为了解决CVCS中出现的问题，在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。

    更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。 你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。


## GIT
### 简介：
    是一个开源的分布式版本控制系统（Distributed Version Control System），可以有效、高速地处理从很小到非常大的项目版本管理。

### 优点：
1. 适合分布式开发，强调个体。  
2. 公共服务器压力和数据量都不会太大。  
3. 速度快、灵活。  
4. 任意两个开发者之间可以很容易的解决冲突。  
5. 离线工作。
### 缺点：
1. 资料少（起码中文资料很少）。  
2. 学习周期相对而言比较长。  
3. 不符合常规思维。  
4. 代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。

### git-flow
    一旦安装安装 git-flow，你将会拥有一些扩展命令。这些命令会在一个预定义的顺序下自动执行多个操作。是的，这就是我们的工作流程！

    git-flow 并不是要替代 Git，它仅仅是非常聪明有效地把标准的 Git 命令用脚本组合了起来。

    严格来讲，你并不需要安装什么特别的东西就可以使用 git-flow 工作流程。你只需要了解，哪些工作流程是由哪些单独的任务所组成的，并且附带上正确的参数，以及在一个正确的顺序下简单执行那些对应的 Git 命令就可以了。

    创建一个新功能：git flow feature start feature_name;
    指令更改结束：git flow feature end feature_name;

    当在项目的根目录执行 “git flow init” 命令时,会询问用户几个问题并进行必要设置

## SVN(Subversion)

### 简介：
    Subversion用于维护项目的当前版本和历史版本，它采用了分支管理系统。它是一个开源的集中式版本控制系统（Centralized Version Control Systems）.

    数据放置在一个 repository 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。

### SVN 的一些概念：
1. repository（源代码库）:源代码统一存放的地方
2. Checkout（提取）:当你手上没有源代码的时候，你需要从 repository checkout 一份
3. Commit（提交）:当你已经修改了代码，你就需要Commit到repository
4. Update (更新):当你已经 checkout 了一份源代码， update 一下你就可以和Repository上的源代码同步，你手上的代码就会有最新的变更

### 访问 SVN 存储库
1. ```file:///```：直接访问 SVN 存储库（在本地硬盘上）

2. ```http://```:通过WebDAV协议访问SVN支持的Apache服务器

3. ```https://```:作为 ```http://```，但使用 SSL 加密

4. ```svn://``` :通过自己的协议访问 svnserve 服务器

5. ```svn+ssh://```:作为 ```svn://```，但通过 SSH 建立隧道

### 存储库（Repository）:
存储和维护任何数据的地方。大多数情况下，存储库中的数据以文件的形式存储，可以通过网络进一步分发。它们存储所有文档及其更改历史和其他服务信息

### trunk、branch、tag：
**trunk**：是开发的主体，从项目开始一直到现在。

**branch**：是从主干中的某个点派生的代码副本，用于对代码进行重大更改，同时保持主干中代码的完整性。如果主要更改按计划进行，它们通常会合并回主干。Branch 选项会给开发者创建出另外一条线路。当有人希望开发进程分开成两条不同的线路时，这个选项会非常有用。

**tag**：是您希望保留的主干或分支上的时间点。保留的两个主要原因是这是软件的主要版本，无论是 alpha、beta、RC 还是 RTM，或者这是在主干上应用重大修订之前软件的最稳定点。我们可以给某一个具体版本的代码一个更加有意义的名字。

### 冲突
#### 类型：
**内容冲突**：当两名(或更多)开发人员修改了同一个文件中相邻或相同的行时就会发生文件冲突。    
**树冲突（课件上叫结构冲突）**：当一名开发人员移动、重命名、删除一个文件或文件夹，而另一名开发人员也对它们进行了移动、重命名、删除或者仅仅是修改，在更新时就会发生树冲突。
#### 解决方案：
**内容冲突**：可选择使用```svn postpone```将处理推迟，或者与开发者联系，并协调恢复。  
**结构冲突**：可以通过根据repository中的版本更改本地副本中的结构来解决冲突，也可以通过与更改存储库中结构的人就修复达成一致。

### 优点：
1. 轻松比较不同版本间的细微差别【修改了代码，就有版本号，还能知道修改前后的数据
2. 及时了解团队中其他成员的进度【如果没有把代码提交到服务器中，就是做得比较慢了】
3. 广域网共享【连上局域网就可以代码共享了】
4. 协同工作，大大提高团队工作效率

### 优于 CVS 之处：
1. 原子提交：一次提交不管是单个还是多个文件，都是作为一个整体提交的，所以要么全部提交成功，要么就是全部不成功，这样就不会引起数据库的不完整和数据损坏。
2. 重新名、复制、删除文件等动作都保存在版本历史记录当中。
3. 对于二进制文件，使用了节省空间的保存方法。（简单的理解，就是只保存和上一版本不同之处）
4. 目录也有版本历史。整个目录树可以被移动或者复制，操作很简单，而且能够保留全部版本记录。
5. 分支的开销非常小。
6. 优化过的数据库访问，使得一些操作不必访问数据库就可以做到。这样减少了很多不必要的和数据库主机之间的网络流量。




## git基本命令
### 概念：
1. **工作区**：本地电脑存放项目文件的地方，比如文件夹；  
2. **暂存区（Index/Stage）**：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里；  
3. **本地仓库**：.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中；  
4. **远程仓库**：不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后push到远程仓库中即可；

### 配置信息：
1.  列出当前配置：```git config --list```;   
2. 列出repository配置：```git config --local --list```;   
3. 列出全局配置：```git config --global --list```;   
4. 列出系统配置：```git config --system --list```;  


### 第一次使用git，配置用户信息
1. 配置用户名：```git config --global user.name "your name"```;  
2. 配置用户邮箱：```git config --global user.email $"youremail@github.com"```;

### 新建仓库
1. 将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：```git init```；  
2. 从远程git仓库复制项目：```git clone <url>```，如：```git clone git://github.com/wasd/example.git```;  
3. 克隆项目时如果想定义新的项目名，可以在clone命令后指定新的项目名：```git clone git://github.com/wasd/example.git mygit```；


### 提交
1. 提交工作区所有文件到暂存区：```git add .```
2. 提交工作区中指定文件到暂存区：```git add <file1> <file2> ...```;
3. 提交工作区中某个文件夹中所有文件到暂存区：``git add [dir]``;


### 撤销
1. 删除工作区文件，并且也从暂存区删除对应文件的记录：```git rm <file1> <file2>```;
2. 从暂存区中删除文件，但是工作区依然还有该文件:```git rm --cached <file>```;
3. <front color="red"> 取消暂存区已经暂存的文件：```git reset HEAD <file>...```;<front color="red">
4. 撤销上一次对文件的操作：```git checkout --<file>```
5. 查看当前所有的储藏：```git stash list```

### 更新文件
1. 重命名文件，并将已改名文件提交到暂存区：```git mv [file-original] [file-renamed]```

### 查新信息
1. 查询当前工作区所有文件的状态：```git status;```
2. 比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：```git diff```；
指定文件在工作区和暂存区上差异比较：```git diff <file-name>```

### 提交文件到版本库
1. 暂存区中的文件提交到本地仓库中，即打上新版本：```git commit -m "commit_info"```;
2. 将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程：```git commit -a -m "commit_info"```;
3. 提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交：```git commit --amend```

### 分支管理
1. 创建分支：```git branch <branch-name>```
2. 从当前所处的分支切换到其他分支：```git checkout <branch-name>```
3. 新建并切换到新建分支上：```git checkout -b <branch-name>```;
4. 删除分支：```git branch -d <branch-name>```；
5. 将当前分支与指定分支进行合并：```git merge <branch-name>```;
6. 显示本地仓库的所有分支：```git branch```;
7. 从远程分支``checkout``出来的本地分支，称之为**跟踪分支**。在跟踪分支上向远程分支上推送内容：```git push```。该命令会自动判断应该向远程仓库中的哪个分支推送数据；在跟踪分支上合并远程分支：```git pull```；
8. 查看提交历史：```git log```  
    ```-p```：显示每个提交所引入的更改。    
    ```git log -p -5```显示最近的 5 个提交  
    ```--graph```:以图形方式显示提交历史  
9. ```git show-branch  ```  
    *：当前所在的分支。  
    +：该分支包含当前分支的所有提交。  
    -：该分支包含部分当前分支的提交。  
    |：分支分叉点。  
    =：该分支包含与当前分支相同的提交。  
    <：该分支包含当前分支尚未包含的提交。  
    $>$：当前分支包含该分支尚未包含的提交。  


### 本地仓库上的操作
1. 查看本地仓库关联的远程仓库：```git remote```；在克隆完每个远程仓库后，远程仓库默认为origin;加上-v的参数后，会显示远程仓库的url地址；
2. 添加远程仓库，一般会取一个简短的别名：```git remote add [remote-name] [url]```，比如：```git remote add example git://github.com/example/example.git```;
3. 从远程仓库中抓取本地仓库中没有的更新：```git fetch [remote-name]```，如```git fetch origi```n;使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用git pull来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；
4. 将本地仓库某分支推送到远程仓库上：```git push [remote-name] [branch-name]```，如```git push origin master```；如果想将本地分支推送到远程仓库的不同名分支：```git push <remote-name> <local-branch>:<remote-branch> ``` 
5. 如果想删除远程分支：```git push [remote-name] :<remote-branch>```，如```git push origin :serverfix```。这里<front color="red">省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支<front color="red">。
6. 移除远程仓库：```git remote rm [remote-name]```；

## SVN基本命令
1. 从SVN库中提取对应项目:```svn checkout svn://192.168.1.1/myproject/doc  /home/test/  --username myname --password password``` svn项目路径为``svn://192.168.1.1/myproject/doc``，将项目路径下的文件checkout到``/home/test``目录下，若没有``/home/test``路径会自动创建，同时只将doc中的子目录和文件checkout到该路径。
2. 添加单个文件：```svn add file```
3. 添加全部文件：```svn add *```
4. 提交文件：```svn commit -m "message"```
5. 删除文件：```svn delete file```   
        <front color="red">``del`` ``rm`` 都可以<front color="red">
6. 查看当前目录文件状态：```svn status```
7.  ### 查看提交日志
    (1). 查看所有记录:```svn log```  
    (2). 查看最近的N条提交记录:```svn log -ln```  
    (3). 查看file文件的记录:```svn log file```
8. 查看file项目的svn信息：```svn info file```
9.  查看目录下有什么文件：```svn list svn://..../..```
10. ### 文件修改之后回退:
    (1).撤销对file的修改:```svn revert file```  
    (2). 撤销当前目录下的所有修改：```svn revert --recursive```
11. ### 文件对比：
    （1）查看文件与svn中的不同： ```svn diff file```  
    （2）查看file在版本为12与14之间所做的修改：```svn diff -r 12:14 file```
12. 将两个版本之间的差异合并到当前文件：```svn merge -r m:n path```
13. 代码库URL变更：更新工作副本至不同的URL ```svn switch URL```
14. ### 冲突：
    (1). 解决冲突：移除工作副本的目录或文件的“冲突”状态 ```svn resolved(r)```   
    注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的相关文件，然后让 file 可以再次提交。  
    (2). 显示所有冲突：```svn display-conflict(dc)```
    (3). ```svn theirs-conflict```:意味着当尝试签入两个具有冲突编辑的文件时，SVN 将放弃自己的更改并改用其他人的更改。  
    (4). ```svn mine-conflict```:解决冲突意味着将放弃他们的更改，并改用自己的文件版本。  
    (5). ```svn mine-full```: 将使用自己的整个文件，丢弃他们的所有更改  
    (6). ```svn theirs-full```: 将使用他们的整个文件  
        'conflict' 和 'full' 区别：conflict是在冲突时使用自己/对方的更改，其他仍旧合并；而full是整个使用自己的文件。  
    (7). ```svn postpone```:将conflict标记为稍后解决  
    (8). ```svn edit```:在编辑器中更改合并文件  
    (9). ```svn diff-full```:显示对合并文件所做的所有更改  
    (10). ```svn launch``` :启动外部工具来解决冲突
15. 拷贝工作副本的一个文件或目录到版本库：```svn copy (cp) file1 file2```
16. 合并：将url合并到当前 ```svn merge URL``` 
17. 

### **Lock-Modify-Unlock**
    许多版本控制系统使用 "Lock-Modify-Unlock" 模型来解决许多作者互相破坏彼此工作的问题。在此模型中，存储库一次只允许一个人更改文件。这种排他性政策是使用锁来管理的。Herry 必须先“Lock”一个文件，然后才能开始对其进行更改。如果 Herry 锁定了一个文件，则 Sally 也不能锁定它，因此不能对该文件进行任何更改。她所能做的就是阅读文件，并等待Herry完成更改并释放他的锁。Herry UnLock文件后，Sally 可以轮到她锁定和编辑文件。

    缺点：
    Lock可能会导致管理问题。 有时 Herry 会Lock一个文件，然后就忘了它。同时，由于 Sally 仍在等待编辑文件。但是Herry去度假了。现在 Sally 必须让管理员解除 Herry 的锁。这种情况最终会造成很多不必要的延误和浪费时间。

    Lock可能会导致不必要的序列化。 如果 Herry 正在编辑文本文件的开头，而 Sally 只想编辑同一个文件的结尾怎么办？这些变化根本不重叠。他们可以很容易地同时编辑文件，并且不会造成太大的伤害，假设更改被适当地合并在一起。在这种情况下，他们没有必要轮流。

    Lock可能会产生一种虚假的安全感。 假设 Herry 锁定并编辑文件 A，而 Sally 同时锁定并编辑文件 B。但是如果 A 和 B 相互依赖，并且对每个文件所做的更改在语义上不兼容怎么办,那么A和B不能同时运行。

### **Copy-Modify-Merge**
    Subversion、CVS 和许多其他版本控制系统使用 "Copy-Modify-Merge" 模型作为Lock的替代方法。在此模型中，每个用户的客户端都会联系项目存储库并创建个人的工作副本——存储库文件和目录的本地反映。然后用户同时独立工作，修改他们的私人副本。最后，将私有副本合并为一个新的最终版本。版本控制系统通常协助Merge，但最终由管理员来负责使其正确发生。

    如果更改重叠怎么办？然后怎样呢？这种情况称为 "conflict"，这通常不是什么大问题。当人们要求他的客户将最新的存储库更改合并到他的工作副本中时，他的文件 A 的副本以某种方式被标记为处于冲突状态：他将能够看到两组冲突的更改，并在它们之间手动选择. 请注意，软件无法自动解决冲突；只有人类能够理解并做出必要的明智选择。

    Copy-Modify-Merge 模型听起来有点混乱，但实际上运行起来非常流畅。用户可以并行工作，无需等待。当他们处理相同的文件时，事实证明他们的大部分并发更改根本不重叠；冲突很少见。解决冲突所花费的时间通常远少于锁定系统所损失的时间。

    最后，这一切都归结为一个关键因素：用户沟通。当用户沟通不畅时，句法和语义冲突都会增加。没有系统可以强迫用户进行完美的交流，也没有系统可以检测到语义冲突。因此，没有必要误以为锁定系统会以某种方式防止冲突；实际上，锁定似乎比其他任何东西都更能抑制生产力。

虽然 Lock-Modify-Unlock 模型通常被认为不利于协作，但有时锁定还是合适的。

Copy-Modify-Merge 模型基于文件是上下文可合并的假设：也就是说，存储库中的大部分文件都是基于行的文本文件（例如程序源代码）。但是对于二进制格式的文件，例如艺术作品或声音，通常不可能合并冲突的更改。在这些情况下，用户在更改文件时确实有必要严格轮流。如果没有序列化访问，有人最终会在最终被丢弃的更改上浪费时间。

虽然 Subversion 仍然主要是一个 Copy-Modify-Merge 系统，但它仍然认识到需要锁定偶尔的文件

## **冲突**

### 类型：
**内容冲突**：当两名(或更多)开发人员修改了同一个文件中相邻或相同的行时就会发生文件冲突。  
**树冲突**：当一名开发人员移动、重命名、删除一个文件或文件夹，而另一名开发人员也对它们进行了移动、重命名、删除或者仅仅是修改，在更新时就会发生树冲突。

## GIT和SVN的比较
1. ### SVN是**集中式管理的版本控制器（Centralized Version Control Systems）**，而Git是**分布式管理的版本控制器（Distributed Version Control System）**，这是两者之间最核心的区别。
2. ### SVN只有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。  
    Git每一个终端都是一个仓库，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来，每一次的提取操作，实际上都是一次对代码仓库的完整备份。
3. ### GIT更灵活：
    搭载SVN的服务器如果出现故障，就无法与之交互。 但是GIT可以在本地仓库工作
4. ### 安全性：SVN较差，定期备份，并且是整个SVN都得备份。GIT每一个开发者的本地就是一套较为完整的库
5. ### 工作流程：  
#### SVN：  
    每次更改文件之前都得update操作，有的时候修改过程中这个文件有更新，commit不会成功。  
    有冲突，会打断提交动作，冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决。  
#### GIT：  
    开始工作前进行fetch操作，完成开发工作后push操作，有冲突解决冲突。  
    Git的提交过程不会被打断，有冲突会标记冲突文件。  
    Gitflow经典流程。

6. ### 学习成本：
GIT更在乎效率而不是易用性，成本较高
